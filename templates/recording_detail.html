<!DOCTYPE html>
<html>
<head>
    <title>{{ recording.meeting_title }} - Recording Details</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loading {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #e5e7eb;
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        details[open] summary svg {
            transform: rotate(180deg);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-500 to-purple-600 min-h-screen p-5">
    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <div class="bg-white rounded-xl p-6 mb-8 shadow-lg flex flex-col md:flex-row justify-between items-start gap-4">
            <div class="flex-1">
                <h1 class="text-gray-800 text-3xl font-bold mb-2">{{ recording.meeting_title }}</h1>
                <div class="text-gray-600 text-sm space-y-1">
                    {% if recording.meeting_link %}
                    <p>
                        <a href="{{ recording.meeting_link }}" target="_blank"
                           class="text-indigo-600 hover:text-indigo-800 underline inline-flex items-center gap-1">
                            üìã View Meeting Agenda
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                      d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                            </svg>
                        </a>
                    </p>
                    {% endif %}
                </div>

                <!-- Technical details collapsed by default -->
                <details class="mt-4">
                    <summary class="cursor-pointer text-sm text-gray-600 hover:text-gray-800 font-semibold inline-flex items-center gap-2">
                        üîß Technical Details
                        <svg class="w-4 h-4 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </summary>
                    <div class="mt-3 p-4 bg-gray-50 rounded-lg text-sm space-y-2">
                        <div class="flex justify-between">
                            <span class="text-gray-600">Recording ID:</span>
                            <span class="font-mono text-gray-800">{{ recording.id }}</span>
                        </div>
                        {% if recording.meeting_id %}
                        <div class="flex justify-between">
                            <span class="text-gray-600">Meeting ID:</span>
                            <span class="font-mono text-gray-800">{{ recording.meeting_id }}</span>
                        </div>
                        {% endif %}
                    </div>
                </details>
            </div>
            <a href="/recordings" class="text-indigo-600 font-semibold px-4 py-2 rounded-lg hover:bg-gray-50 transition whitespace-nowrap">
                ‚Üê Back to Recordings
            </a>
        </div>

        <!-- Recording Info Card -->
        <div class="bg-white rounded-xl p-6 mb-8 shadow-lg">
            <h2 class="text-gray-800 text-2xl font-bold mb-4 pb-3 border-b-2 border-gray-200">Recording Information</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div class="bg-gray-50 p-4 rounded-lg">
                    <div class="text-gray-600 text-sm mb-2">Status</div>
                    <div class="inline-flex items-center gap-2">
                        <!-- Primary status badge -->
                        <span class="px-3 py-1 rounded-full text-xs font-semibold
                            {% if recording.status == 'completed' %}bg-green-100 text-green-700
                            {% elif recording.status == 'failed' %}bg-red-100 text-red-700
                            {% else %}bg-orange-100 text-orange-700{% endif %}">
                            {% if recording.status == 'completed' %}‚úì{% elif recording.status == 'failed' %}‚úï{% else %}‚è≥{% endif %}
                            {{ recording.status.title() }}
                        </span>

                        <!-- Retry button for failed downloads -->
                        {% if recording.status == 'failed' %}
                            <button onclick="retryDownload()"
                                    id="retry-download-btn"
                                    class="px-3 py-1 text-xs bg-red-600 text-white rounded hover:bg-red-700 transition font-semibold disabled:opacity-50 disabled:cursor-not-allowed"
                                    title="Retry downloading this recording">
                                üîÑ Retry Download
                            </button>
                        {% endif %}

                        <!-- Secondary status indicators (subtle) -->
                        {% if recording.status == 'completed' %}
                            {% set pp_status = recording.post_process_status or 'pending' %}
                            {% set trans_status = recording.transcription_status or 'pending' %}
                            <span class="text-xs text-gray-600">
                                {% if pp_status == 'completed' %}‚Ä¢ WAV Extracted{% endif %}
                                {% if trans_status == 'completed' %} ‚Ä¢ Transcribed{% endif %}
                            </span>

                            <!-- Show processing status if actively processing transcription -->
                            {% if trans_status == 'processing' %}
                                <span class="px-2 py-0.5 rounded-full text-xs font-semibold bg-yellow-100 text-yellow-700 inline-flex items-center gap-1">
                                    <span class="loading"></span>
                                    <span>Transcribing...</span>
                                </span>
                                <button onclick="resetTranscriptionStatus()"
                                        class="px-2 py-1 text-xs bg-orange-500 text-white rounded hover:bg-orange-600 transition"
                                        title="Reset status if stuck">
                                    üîÑ Reset
                                </button>
                            {% endif %}
                        {% endif %}
                    </div>

                    <!-- Download progress bar for downloading status -->
                    {% if recording.status == 'downloading' %}
                        <div class="mt-3">
                            <div class="flex justify-between text-xs text-gray-600 mb-1">
                                <div class="flex items-center gap-2">
                                    <span>Downloading...</span>
                                    <span id="download-speed" class="text-blue-600 font-medium">
                                        {% if recording.download_speed %}{{ recording.download_speed }}{% endif %}
                                    </span>
                                </div>
                                <span id="progress-percentage">{{ recording.download_progress or 0 }}%</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2">
                                <div id="progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: {{ recording.download_progress or 0 }}%"></div>
                            </div>
                        </div>
                    {% endif %}

                    <!-- Error message for failed recordings -->
                    {% if recording.status == 'failed' and recording.error_message %}
                        <div class="mt-2 text-sm text-red-600 bg-red-50 border border-red-200 rounded p-2">
                            <strong>Error:</strong> {{ recording.error_message }}
                        </div>
                    {% endif %}
                </div>

                <div class="bg-gray-50 p-4 rounded-lg">
                    <div class="text-gray-600 text-sm mb-1">Start Time</div>
                    <div class="text-gray-800 font-semibold">{{ recording.start_time }}</div>
                </div>

                {% if recording.end_time %}
                <div class="bg-gray-50 p-4 rounded-lg">
                    <div class="text-gray-600 text-sm mb-1">End Time</div>
                    <div class="text-gray-800 font-semibold">{{ recording.end_time }}</div>
                </div>
                {% endif %}

                {% if recording.duration_minutes %}
                <div class="bg-gray-50 p-4 rounded-lg">
                    <div class="text-gray-600 text-sm mb-1">Duration</div>
                    <div class="text-gray-800 font-semibold">{{ recording.duration_minutes }} minutes</div>
                </div>
                {% endif %}

                {% if recording.file_size_mb %}
                <div class="bg-gray-50 p-4 rounded-lg">
                    <div class="text-gray-600 text-sm mb-1">File Size</div>
                    <div class="text-gray-800 font-semibold">{{ recording.file_size_mb }} MB</div>
                </div>
                {% endif %}

                {% if recording.pyannote_media_url %}
                <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                    <div class="text-blue-700 text-sm mb-1 font-semibold">‚òÅÔ∏è Pyannote Cloud Upload</div>
                    <div class="text-blue-600 text-xs font-mono break-all">{{ recording.pyannote_media_url }}</div>
                    {% if recording.pyannote_upload_size_mb %}
                    <div class="text-blue-600 text-xs mt-1">Uploaded: {{ "%.1f"|format(recording.pyannote_upload_size_mb) }} MB</div>
                    {% endif %}
                    <div class="text-blue-500 text-xs mt-1">‚úì Available for reuse if diarization fails</div>
                </div>
                {% endif %}
            </div>

            {% if recording.post_process_error %}
            <div class="bg-red-50 border border-red-200 rounded-lg p-4 mt-4">
                <div class="text-red-700 font-semibold mb-1">Post-Processing Error</div>
                <div class="text-red-600 text-sm">{{ recording.post_process_error }}</div>
            </div>
            {% endif %}
        </div>

        <!-- Post-Processing Card -->
        {% if recording.status == 'completed' and recording.post_process_status != 'completed' %}
        <div class="bg-white rounded-xl p-6 mb-8 shadow-lg">
            <div class="flex justify-between items-center mb-4 pb-3 border-b-2 border-gray-200">
                <div>
                    <h2 class="text-gray-800 text-2xl font-bold">üéµ Extract Audio</h2>
                    <p class="text-gray-600 text-sm mt-1">Extract WAV audio for transcription and diarization</p>
                </div>
                <button id="postprocess-btn"
                        class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition font-semibold text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                        onclick="startPostProcessing()">
                    <span id="postprocess-btn-text">Extract WAV</span>
                    <span id="postprocess-btn-loading" class="hidden inline-flex items-center gap-2">
                        <span class="loading"></span> Extracting...
                    </span>
                </button>
            </div>
            <div id="postprocess-status" class="text-sm text-gray-600">
                {% if recording.post_process_status == 'pending' %}
                    WAV audio has not been extracted yet. Click "Extract WAV" to prepare for transcription.
                {% elif recording.post_process_status == 'processing' %}
                    <span class="text-orange-600">‚è≥ Extracting audio...</span>
                {% elif recording.post_process_status == 'failed' %}
                    <span class="text-red-600">‚úï Extraction failed: {{ recording.post_process_error }}</span>
                {% endif %}
            </div>

            <!-- Post-processing logs -->
            <div id="postprocess-logs" class="mt-4 space-y-1 {% if recording.post_process_status != 'processing' %}hidden{% endif %}">
                <div class="text-xs font-semibold text-gray-700 mb-2">Progress:</div>
                <div id="postprocess-logs-container" class="text-xs text-gray-600 space-y-1 max-h-60 overflow-y-auto bg-gray-50 rounded p-3">
                    <!-- Logs will be inserted here -->
                </div>
            </div>
        </div>
        {% endif %}

        <!-- Active Background Tasks Card -->
        <div id="background-tasks-card" class="bg-white rounded-xl p-6 mb-8 shadow-lg hidden">
            <h2 class="text-gray-800 text-2xl font-bold mb-4 pb-3 border-b-2 border-gray-200">‚öôÔ∏è Active Background Tasks</h2>
            <div id="background-tasks-container" class="space-y-3">
                <!-- Tasks will be loaded here -->
            </div>
        </div>

        <!-- Transcription Progress Card -->
        {% if recording.status == 'completed' %}
        <div id="transcription-progress-card" class="bg-white rounded-xl p-6 mb-8 shadow-lg">
            <div class="flex justify-between items-center mb-4 pb-3 border-b-2 border-gray-200">
                <div class="flex items-center gap-3">
                    <h2 class="text-gray-800 text-2xl font-bold">üéôÔ∏è Transcription Progress</h2>
                    {% if recording.diarization_status %}
                        {% if recording.diarization_status == 'running' %}
                            <span class="px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700 inline-flex items-center gap-1">
                                <span class="loading"></span>
                                <span>Processing</span>
                            </span>
                        {% elif recording.diarization_status == 'completed' %}
                            <span class="px-3 py-1 rounded-full text-xs font-semibold bg-green-100 text-green-700">
                                ‚úÖ Completed
                            </span>
                        {% elif recording.diarization_status == 'failed' %}
                            <span class="px-3 py-1 rounded-full text-xs font-semibold bg-red-100 text-red-700">
                                ‚ùå Failed
                            </span>
                        {% elif recording.diarization_status == 'pending' %}
                            <span class="px-3 py-1 rounded-full text-xs font-semibold bg-yellow-100 text-yellow-700">
                                ‚è≥ Pending
                            </span>
                        {% endif %}
                        {% if recording.pyannote_job_id %}
                            <span class="text-xs text-gray-500" title="Pyannote Job ID">
                                Job: {{ recording.pyannote_job_id[:8] }}...
                            </span>
                        {% endif %}
                    {% endif %}
                </div>
                <button id="transcribe-btn"
                        class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-semibold text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                        onclick="startOrResumeTranscription()">
                    <span id="transcribe-btn-text">Start Transcription</span>
                    <span id="transcribe-btn-loading" class="hidden inline-flex items-center gap-2">
                        <span class="loading"></span> Processing...
                    </span>
                </button>
            </div>

            <!-- Step Progress Indicators -->
            <div id="transcription-steps" class="space-y-3">
                <!-- Steps will be dynamically loaded here -->
            </div>

            <!-- Overall Status Message -->
            <div id="transcription-status-message" class="mt-4 p-4 rounded-lg hidden">
                <!-- Status message will be shown here -->
            </div>
        </div>
        {% else %}
        <div class="bg-white rounded-xl p-6 mb-8 shadow-lg">
            <h2 class="text-gray-800 text-2xl font-bold mb-4 pb-3 border-b-2 border-gray-200">üéôÔ∏è Transcription</h2>
            <div class="text-center py-10 text-gray-500">
                <div class="text-5xl mb-4">‚è≥</div>
                <p>Recording must be completed before transcription can begin</p>
            </div>
        </div>
        {% endif %}

        <!-- Speakers Card -->
        <div id="speakers-card" class="bg-white rounded-xl p-6 mb-8 shadow-lg hidden">
            <div class="flex justify-between items-center mb-4 pb-3 border-b-2 border-gray-200">
                <h2 class="text-gray-800 text-2xl font-bold">üé§ Meeting Speakers</h2>
                <button id="refresh-speakers-btn"
                        class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-semibold text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                        onclick="fetchSpeakersFromAgenda()">
                    <span id="refresh-speakers-text">üîÑ Refresh Speakers</span>
                    <span id="refresh-speakers-loading" class="hidden inline-flex items-center gap-2">
                        <span class="loading"></span> Fetching...
                    </span>
                </button>
            </div>
            <div id="speakers-content" class="grid grid-cols-1 md:grid-cols-2 gap-3">
                <!-- Speakers will be loaded here -->
            </div>
        </div>

        <!-- No Speakers Card (shown when no speakers available) -->
        <div id="no-speakers-card" class="bg-white rounded-xl p-6 mb-8 shadow-lg hidden">
            <h2 class="text-gray-800 text-2xl font-bold mb-4 pb-3 border-b-2 border-gray-200">üé§ Meeting Speakers</h2>
            <div class="text-center py-10 text-gray-500">
                <div class="text-5xl mb-4">üë•</div>
                <p class="mb-4">No speaker information available yet</p>
                <button id="fetch-speakers-btn"
                        class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-semibold text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                        onclick="fetchSpeakersFromAgenda()">
                    <span id="fetch-speakers-text">üîç Fetch Speakers from Agenda</span>
                    <span id="fetch-speakers-loading" class="hidden inline-flex items-center gap-2">
                        <span class="loading"></span> Fetching...
                    </span>
                </button>
                <p class="text-sm text-gray-400 mt-4">This will extract speaker names from the meeting agenda</p>
            </div>
        </div>

        <!-- Transcript Card -->
        {% if recording.has_transcript %}
        <div class="bg-white rounded-xl p-6 mb-8 shadow-lg">
            <div class="flex justify-between items-center mb-4 pb-3 border-b-2 border-gray-200">
                <h2 class="text-gray-800 text-2xl font-bold">üìÑ Transcript & Diarization</h2>
                <div class="relative inline-block download-dropdown">
                    <button class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold text-sm inline-flex items-center gap-2"
                            onclick="toggleDropdown(event, 'download-recording')"
                            aria-haspopup="true"
                            aria-expanded="false"
                            aria-controls="download-recording">
                        üìÑ Download
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>

                    <div id="download-recording" class="hidden absolute right-0 mt-2 w-56 rounded-lg shadow-lg bg-white ring-1 ring-black ring-opacity-5 z-10" role="menu">
                        <div class="py-1">
                            <a href="/download/transcript/{{ recording.id }}"
                               class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                               role="menuitem">
                                üìÑ Transcript (JSON)
                            </a>
                            {% if recording.diarization_pyannote_path %}
                            <a href="/download/diarization/pyannote/{{ recording.id }}"
                               class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                               role="menuitem">
                                üéØ Pyannote Diarization
                            </a>
                            {% endif %}
                            {% if recording.diarization_gemini_path %}
                            <a href="/download/diarization/gemini/{{ recording.id }}"
                               class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                               role="menuitem">
                                ‚ú® Gemini Refined
                            </a>
                            {% endif %}
                        </div>
                    </div>
                </div>
            </div>
            <div class="bg-gray-50 p-4 rounded-lg">
                <p class="text-gray-600 text-sm">Full recording transcript and speaker diarization data available for download</p>
                {% if recording.diarization_gemini_path %}
                <p class="text-gray-600 text-sm mt-2">‚ú® <strong>Gemini-refined:</strong> Speaker labels improved with AI using meeting agenda context</p>
                {% endif %}
            </div>
        </div>
        {% endif %}

        <!-- Segments removed - no longer using segmentation -->

        <!-- Logs Card -->
        {% if logs %}
        <div class="bg-white rounded-xl p-6 mb-8 shadow-lg">
            <details>
                <summary class="cursor-pointer text-gray-800 text-2xl font-bold mb-4 pb-3 border-b-2 border-gray-200 flex items-center gap-2 w-full">
                    üìù Processing Logs
                    <span class="text-sm font-normal text-gray-600">({{ logs|length }} entries)</span>
                    <svg class="w-5 h-5 transform transition-transform ml-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </summary>
                <div class="mt-4 bg-gray-900 rounded-lg p-4 overflow-auto max-h-96">
                    <div class="font-mono text-sm space-y-1">
                        {% for log in logs %}
                        <div class="flex gap-3 {% if log.level == 'error' %}text-red-400
                                               {% elif log.level == 'warning' %}text-yellow-400
                                               {% else %}text-gray-300{% endif %}">
                            <span class="text-gray-500 shrink-0 text-xs">
                                {{ log.timestamp[11:19] }}
                            </span>
                            <span class="shrink-0 font-semibold
                                {% if log.level == 'error' %}text-red-500
                                {% elif log.level == 'warning' %}text-yellow-500
                                {% else %}text-blue-400{% endif %}">
                                [{{ log.level.upper() }}]
                            </span>
                            <span class="break-words">{{ log.message }}</span>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </details>
        </div>
        {% endif %}
    </div>

    <script>
        // Poll for download progress updates
        let progressInterval = null;

        function startProgressPolling() {
            const progressBar = document.getElementById('progress-bar');
            const progressPercentage = document.getElementById('progress-percentage');
            const downloadSpeed = document.getElementById('download-speed');

            if (!progressBar || !progressPercentage) {
                return; // Not on downloading status
            }

            progressInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/recordings/{{ recording.id }}/progress');
                    const data = await response.json();

                    if (data.success) {
                        const progress = data.progress || 0;
                        progressBar.style.width = progress + '%';
                        progressPercentage.textContent = progress + '%';

                        // Update download speed if available
                        if (downloadSpeed && data.speed) {
                            downloadSpeed.textContent = data.speed;
                        }

                        // If completed or failed, reload page
                        if (data.status === 'completed' || data.status === 'failed') {
                            clearInterval(progressInterval);
                            setTimeout(() => {
                                window.location.reload();
                            }, 1000);
                        }
                    }
                } catch (error) {
                    console.error('Error fetching progress:', error);
                }
            }, 2000); // Poll every 2 seconds
        }

        // Start polling if recording is downloading
        {% if recording.status == 'downloading' %}
        startProgressPolling();
        {% endif %}

        // Retry downloading a failed recording
        async function retryDownload() {
            const btn = document.getElementById('retry-download-btn');
            if (!btn) return;

            btn.disabled = true;
            btn.textContent = '‚è≥ Retrying...';

            try {
                const response = await fetch('/api/recordings/{{ recording.id }}/retry-download', {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    btn.textContent = '‚úì Retry Started';
                    btn.classList.remove('bg-red-600', 'hover:bg-red-700');
                    btn.classList.add('bg-green-600');

                    // Reload page to show downloading status with progress bar
                    setTimeout(() => {
                        window.location.reload();
                    }, 1000);
                } else {
                    btn.textContent = '‚úï Retry Failed';
                    btn.disabled = false;
                    alert('Failed to retry download: ' + (data.message || 'Unknown error'));
                    setTimeout(() => {
                        btn.textContent = 'üîÑ Retry Download';
                    }, 3000);
                }
            } catch (error) {
                console.error('Error retrying download:', error);
                btn.textContent = '‚úï Error';
                btn.disabled = false;
                alert('Error: ' + error.message);
                setTimeout(() => {
                    btn.textContent = 'üîÑ Retry Download';
                }, 3000);
            }
        }

        // Display speaker cards
        function displaySpeakers(speakers) {
            const speakersCard = document.getElementById('speakers-card');
            const noSpeakersCard = document.getElementById('no-speakers-card');
            const speakersContent = document.getElementById('speakers-content');

            if (speakers && speakers.length > 0) {
                // Clear content
                speakersContent.innerHTML = '';

                // Create speaker cards
                speakers.forEach(speaker => {
                    const speakerDiv = document.createElement('div');
                    speakerDiv.className = 'bg-gray-50 border border-gray-200 rounded-lg p-4';

                    // Determine badge color based on confidence
                    let badgeColor = 'bg-gray-100 text-gray-600';
                    if (speaker.confidence === 'high') {
                        badgeColor = 'bg-green-100 text-green-700';
                    } else if (speaker.confidence === 'medium') {
                        badgeColor = 'bg-yellow-100 text-yellow-700';
                    }

                    // Create elements safely to prevent XSS
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'font-semibold text-gray-800 text-lg mb-1';
                    nameDiv.textContent = speaker.name;

                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'flex gap-2 items-center flex-wrap';

                    const roleSpan = document.createElement('span');
                    roleSpan.className = 'text-sm text-gray-600';
                    roleSpan.textContent = speaker.role;

                    const confidenceSpan = document.createElement('span');
                    confidenceSpan.className = `px-2 py-0.5 rounded-full text-xs font-semibold ${badgeColor}`;
                    confidenceSpan.textContent = speaker.confidence;

                    infoDiv.appendChild(roleSpan);
                    infoDiv.appendChild(confidenceSpan);

                    speakerDiv.appendChild(nameDiv);
                    speakerDiv.appendChild(infoDiv);

                    speakersContent.appendChild(speakerDiv);
                });

                // Show speakers card, hide no speakers card
                speakersCard.classList.remove('hidden');
                noSpeakersCard.classList.add('hidden');
            } else {
                // Show no speakers card, hide speakers card
                speakersCard.classList.add('hidden');
                noSpeakersCard.classList.remove('hidden');
            }
        }

        // Load speaker information
        async function loadSpeakers() {
            try {
                const response = await fetch('/api/recordings/{{ recording.id }}/speakers');
                const data = await response.json();

                if (data.success) {
                    displaySpeakers(data.speakers);
                }
            } catch (error) {
                console.error('Error loading speakers:', error);
                // Show no speakers card on error
                document.getElementById('no-speakers-card').classList.remove('hidden');
            }
        }

        // Fetch speakers from agenda
        async function fetchSpeakersFromAgenda() {
            const fetchBtn = document.getElementById('fetch-speakers-btn');
            const fetchText = document.getElementById('fetch-speakers-text');
            const fetchLoading = document.getElementById('fetch-speakers-loading');
            const refreshBtn = document.getElementById('refresh-speakers-btn');
            const refreshText = document.getElementById('refresh-speakers-text');
            const refreshLoading = document.getElementById('refresh-speakers-loading');

            // Disable buttons and show loading
            if (fetchBtn) {
                fetchBtn.disabled = true;
                fetchText.classList.add('hidden');
                fetchLoading.classList.remove('hidden');
            }
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshText.classList.add('hidden');
                refreshLoading.classList.remove('hidden');
            }

            try {
                const response = await fetch('/api/recordings/{{ recording.id }}/speakers/fetch', {
                    method: 'POST'
                });
                const data = await response.json();

                if (data.success) {
                    // Display the fetched speakers
                    displaySpeakers(data.speakers);
                    alert(`‚úÖ Successfully found ${data.speakers.length} speakers from meeting agenda!`);
                } else {
                    alert(`‚ùå ${data.error || 'Failed to fetch speakers'}`);
                }
            } catch (error) {
                console.error('Error fetching speakers:', error);
                alert('‚ùå Error fetching speakers from agenda');
            } finally {
                // Re-enable buttons and hide loading
                if (fetchBtn) {
                    fetchBtn.disabled = false;
                    fetchText.classList.remove('hidden');
                    fetchLoading.classList.add('hidden');
                }
                if (refreshBtn) {
                    refreshBtn.disabled = false;
                    refreshText.classList.remove('hidden');
                    refreshLoading.classList.add('hidden');
                }
            }
        }

        // Load speakers on page load
        loadSpeakers();

        // ========================================================================
        // Transcription Progress Functions
        // ========================================================================

        const STEP_NAMES = {
            'extraction': 'üìÅ Audio Extraction',
            'diarization': 'üéØüë• Transcription + Diarization (Pyannote)',
            'gemini': '‚ú® Speaker Refinement (Gemini)'
        };

        // Simplified flow: extraction ‚Üí pyannote (transcription+diarization) ‚Üí gemini
        const STEP_ORDER = ['extraction', 'diarization', 'gemini'];

        function getStepIcon(status) {
            switch (status) {
                case 'completed': return '‚úÖ';
                case 'in_progress': return '‚è≥';
                case 'failed': return '‚ùå';
                case 'skipped': return '‚è≠Ô∏è';
                default: return '‚≠ï';
            }
        }

        function getStepColor(status) {
            switch (status) {
                case 'completed': return 'bg-green-100 border-green-300 text-green-800';
                case 'in_progress': return 'bg-blue-100 border-blue-300 text-blue-800';
                case 'failed': return 'bg-red-100 border-red-300 text-red-800';
                case 'skipped': return 'bg-gray-100 border-gray-300 text-gray-600';
                default: return 'bg-gray-50 border-gray-200 text-gray-500';
            }
        }

        function renderTranscriptionSteps(steps, overall_status, progress) {
            const container = document.getElementById('transcription-steps');
            const card = document.getElementById('transcription-progress-card');
            const transcribeBtn = document.getElementById('transcribe-btn');
            const transcribeBtnText = document.getElementById('transcribe-btn-text');

            // Card is already visible (shown by default for completed recordings)
            if (!container) return;  // Exit if card doesn't exist

            container.innerHTML = '';

            // Find the latest completed step
            let latestCompletedStep = null;
            for (let i = STEP_ORDER.length - 1; i >= 0; i--) {
                const stepKey = STEP_ORDER[i];
                if (steps[stepKey]?.status === 'completed') {
                    latestCompletedStep = stepKey;
                    break;
                }
            }

            // Check dependencies for each step
            const canRunStep = (stepName) => {
                const stepDeps = {
                    'extraction': [],
                    'diarization': ['extraction'],
                    'gemini': ['diarization']
                };

                const deps = stepDeps[stepName] || [];
                return deps.every(dep => steps[dep]?.status === 'completed');
            };

            // Render each step
            STEP_ORDER.forEach(stepKey => {
                const step = steps[stepKey] || {};
                const status = step.status || 'pending';
                const stepDiv = document.createElement('div');
                stepDiv.className = `p-4 rounded-lg border-2 ${getStepColor(status)}`;

                const icon = getStepIcon(status);
                const name = STEP_NAMES[stepKey];
                const isLatestCompleted = (stepKey === latestCompletedStep);
                const canRun = canRunStep(stepKey);

                let extraInfo = '';
                if (status === 'failed' && step.error) {
                    extraInfo = `<div class="text-sm text-red-600 mt-2">Error: ${escapeHtml(step.error)}</div>`;
                } else if (status === 'skipped' && step.reason) {
                    extraInfo = `<div class="text-sm text-gray-500 mt-2">Reason: ${escapeHtml(step.reason)}</div>`;
                } else if (step.updated_at) {
                    const time = new Date(step.updated_at).toLocaleTimeString();
                    extraInfo = `<div class="text-xs text-gray-500 mt-1">Last updated: ${time}</div>`;
                }

                // Show progress bar for diarization step (transcription + diarization)
                if (stepKey === 'diarization' && progress && progress.stage === 'diarization') {
                    const percent = progress.percent || 0;
                    const current = progress.current || 0;
                    const total = progress.total || 0;

                    if (progress.step === 'analyzing' && percent > 0) {
                        // Show detailed progress
                        extraInfo += `
                            <div class="mt-3">
                                <div class="flex justify-between text-xs text-gray-600 mb-1">
                                    <span>Processing with Pyannote...</span>
                                    <span>${current}s / ${total}s (${percent}%)</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2">
                                    <div class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: ${percent}%"></div>
                                </div>
                            </div>
                        `;
                    } else {
                        // Show indeterminate state (starting up or preparing)
                        const label = progress.step === 'preparing' ? 'Submitting job to Pyannote...' : 'Uploading to Pyannote API...';
                        extraInfo += `
                            <div class="mt-3">
                                <div class="flex justify-between text-xs text-gray-600 mb-1">
                                    <span>${label}</span>
                                    <span class="loading"></span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2">
                                    <div class="bg-blue-600 h-2 rounded-full animate-pulse" style="width: 100%"></div>
                                </div>
                            </div>
                        `;
                    }
                }

                // Build action buttons
                let buttons = '';

                // Preview Prompt button for Gemini step (show if diarization is completed)
                if (stepKey === 'gemini' && steps['diarization']?.status === 'completed') {
                    buttons += `
                        <button onclick="showGeminiPromptPreview()"
                                class="px-3 py-1 text-xs bg-purple-500 text-white rounded hover:bg-purple-600 transition">
                            üëÅÔ∏è Preview Prompt
                        </button>
                    `;
                }

                // Reset button for latest completed step
                if (isLatestCompleted) {
                    buttons += `
                        <button onclick="resetStep('${stepKey}')"
                                class="px-3 py-1 text-xs bg-orange-500 text-white rounded hover:bg-orange-600 transition ml-2">
                            üîÑ Reset
                        </button>
                    `;
                }

                // Run button - show if dependencies are met
                if (canRun) {
                    if (status === 'completed') {
                        // For completed steps, "Re-run" should truly re-execute:
                        // first reset the step, then run it again.
                        buttons += `
                            <button onclick="resetStep('${stepKey}'); setTimeout(() => runStep('${stepKey}'), 500);"
                                    class="px-3 py-1 text-xs bg-blue-500 hover:bg-blue-600 text-white rounded transition ml-2">
                                ‚ñ∂Ô∏è Re-run
                            </button>
                        `;
                    } else {
                        buttons += `
                            <button onclick="runStep('${stepKey}')"
                                    class="px-3 py-1 text-xs bg-green-500 hover:bg-green-600 text-white rounded transition ml-2">
                                ‚ñ∂Ô∏è Run
                            </button>
                        `;
                    }
                }

                stepDiv.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <span class="text-2xl">${icon}</span>
                            <div>
                                <div class="font-semibold">${name}</div>
                                <div class="text-xs capitalize">${status.replace('_', ' ')}</div>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            ${buttons}
                        </div>
                    </div>
                    ${extraInfo}
                `;

                container.appendChild(stepDiv);
            });

            // Update button text based on status
            const hasAnyCompleted = Object.values(steps).some(s => s.status === 'completed');

            if (overall_status === 'processing') {
                transcribeBtnText.textContent = 'Resume Transcription';
                transcribeBtn.disabled = false;
            } else if (overall_status === 'completed') {
                transcribeBtnText.textContent = '‚úì Transcription Complete';
                transcribeBtn.disabled = true;
                transcribeBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                transcribeBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            } else if (overall_status === 'failed') {
                transcribeBtnText.textContent = 'Retry Transcription';
                transcribeBtn.disabled = false;
            } else if (hasAnyCompleted) {
                // Some steps done but not all - this is a resume scenario
                transcribeBtnText.textContent = 'Resume Transcription';
                transcribeBtn.disabled = false;
            } else {
                transcribeBtnText.textContent = 'Start Transcription';
                transcribeBtn.disabled = false;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function loadTranscriptionStatus() {
            try {
                const response = await fetch('/api/recordings/{{ recording.id }}/transcription-status');
                const data = await response.json();

                if (data.success) {
                    renderTranscriptionSteps(data.steps || {}, data.status, data.progress);

                    // Show completion message
                    if (data.status === 'completed') {
                        const msgDiv = document.getElementById('transcription-status-message');
                        msgDiv.className = 'mt-4 p-4 rounded-lg bg-green-50 border border-green-200';
                        msgDiv.innerHTML = '<div class="text-green-800 font-semibold">‚úÖ Transcription completed successfully! <a href="#" onclick="window.location.reload(); return false;" class="underline">Refresh page</a> to see download buttons.</div>';
                        msgDiv.classList.remove('hidden');
                    } else if (data.status === 'failed') {
                        const msgDiv = document.getElementById('transcription-status-message');
                        msgDiv.className = 'mt-4 p-4 rounded-lg bg-red-50 border border-red-200';
                        msgDiv.innerHTML = `<div class="text-red-800"><strong>‚ùå Transcription failed:</strong> ${escapeHtml(data.error || 'Unknown error')}</div>`;
                        msgDiv.classList.remove('hidden');
                    }
                }
            } catch (error) {
                console.error('Error loading transcription status:', error);
            }
        }

        async function startOrResumeTranscription() {
            const btn = document.getElementById('transcribe-btn');
            const btnText = document.getElementById('transcribe-btn-text');
            const btnLoading = document.getElementById('transcribe-btn-loading');

            btn.disabled = true;
            btnText.classList.add('hidden');
            btnLoading.classList.remove('hidden');

            try {
                const response = await fetch('/api/recordings/{{ recording.id }}/transcribe', {
                    method: 'POST'
                });
                const data = await response.json();

                if (data.success) {
                    // Reload status to show transcription has started
                    loadTranscriptionStatus();
                    // Start polling for progress updates
                    startTranscriptionProgressPolling();
                } else {
                    alert(`‚ùå ${data.error || 'Failed to start transcription'}`);
                    btn.disabled = false;
                }
            } catch (error) {
                console.error('Error starting transcription:', error);
                alert('‚ùå Error starting transcription');
                btn.disabled = false;
            } finally {
                btnText.classList.remove('hidden');
                btnLoading.classList.add('hidden');
            }
        }

        // Run a specific transcription step
        async function runStep(stepName) {
            const stepDisplayName = STEP_NAMES[stepName] || stepName;

            // Confirmation dialog
            const confirmMsg = `Run ${stepDisplayName}?\n\n` +
                `This will execute only this specific step independently.\n\n` +
                `Continue?`;

            if (!confirm(confirmMsg)) {
                return;
            }

            try {
                // Map step names to their individual endpoints
                const stepEndpoints = {
                    'extraction': '/api/recordings/{{ recording.id }}/extract-audio',
                    'diarization': '/api/recordings/{{ recording.id }}/run-diarization',
                    'gemini': '/api/recordings/{{ recording.id }}/run-gemini-refinement'
                };

                const endpoint = stepEndpoints[stepName] || '/api/recordings/{{ recording.id }}/transcribe';

                // Call the specific step endpoint
                const response = await fetch(endpoint, {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    alert(`‚úÖ ${stepDisplayName} started!\n\n${data.message}\n\nRefresh the page to see progress.`);
                    // Reload status to show updated state
                    setTimeout(() => loadTranscriptionStatus(), 1000);
                } else {
                    alert(`‚ùå ${data.error || 'Failed to start step'}`);
                }
            } catch (error) {
                console.error('Error running step:', error);
                alert('‚ùå Error running step');
            }
        }

        // Show Gemini prompt preview
        async function showGeminiPromptPreview() {
            try {
                const response = await fetch('/api/recordings/{{ recording.id }}/gemini-prompt-preview');
                const data = await response.json();

                if (data.success) {
                    // Create modal
                    const modal = document.createElement('div');
                    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
                    modal.onclick = (e) => {
                        if (e.target === modal) modal.remove();
                    };

                    const stats = data.stats;
                    const statsHtml = `
                        <div class="grid grid-cols-2 gap-4 mb-4 text-sm">
                            <div class="bg-gray-50 p-3 rounded">
                                <div class="text-gray-600">Segments</div>
                                <div class="font-semibold text-lg">${stats.num_segments}</div>
                            </div>
                            <div class="bg-gray-50 p-3 rounded">
                                <div class="text-gray-600">Expected Speakers</div>
                                <div class="font-semibold text-lg">${stats.num_speakers}</div>
                            </div>
                            <div class="bg-gray-50 p-3 rounded">
                                <div class="text-gray-600">Prompt Length</div>
                                <div class="font-semibold text-lg">${stats.prompt_length_chars.toLocaleString()} chars</div>
                            </div>
                            <div class="bg-gray-50 p-3 rounded">
                                <div class="text-gray-600">Estimated Tokens</div>
                                <div class="font-semibold text-lg">~${stats.estimated_tokens.toLocaleString()}</div>
                            </div>
                        </div>
                    `;

                    modal.innerHTML = `
                        <div class="bg-white rounded-lg max-w-4xl w-full max-h-[90vh] flex flex-col" onclick="event.stopPropagation()">
                            <div class="p-6 border-b border-gray-200 flex justify-between items-center">
                                <h2 class="text-2xl font-bold text-gray-800">ü§ñ Gemini Prompt Preview</h2>
                                <button onclick="this.closest('.fixed').remove()"
                                        class="text-gray-500 hover:text-gray-700 text-2xl leading-none"
                                        title="Close">
                                    √ó
                                </button>
                            </div>
                            <div class="p-6 overflow-y-auto flex-1">
                                ${statsHtml}
                                <div class="mb-4">
                                    <div class="flex justify-between items-center mb-2">
                                        <h3 class="font-semibold text-gray-700">Prompt that will be sent to Gemini:</h3>
                                        <button onclick="copyPromptToClipboard()"
                                                class="px-3 py-1 text-xs bg-indigo-500 text-white rounded hover:bg-indigo-600 transition">
                                            üìã Copy
                                        </button>
                                    </div>
                                    <pre id="prompt-text" class="bg-gray-900 text-gray-100 p-4 rounded-lg overflow-x-auto text-sm whitespace-pre-wrap">${escapeHtml(data.prompt)}</pre>
                                </div>
                            </div>
                            <div class="p-6 border-t border-gray-200 flex justify-end gap-2">
                                <button onclick="this.closest('.fixed').remove()"
                                        class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition">
                                    Close
                                </button>
                            </div>
                        </div>
                    `;

                    document.body.appendChild(modal);

                    // Add copy function to window
                    window.copyPromptToClipboard = async function() {
                        const promptText = data.prompt;
                        try {
                            await navigator.clipboard.writeText(promptText);
                            alert('‚úÖ Prompt copied to clipboard!');
                        } catch (err) {
                            console.error('Failed to copy:', err);
                            // Fallback: select text
                            const promptElement = document.getElementById('prompt-text');
                            const range = document.createRange();
                            range.selectNode(promptElement);
                            window.getSelection().removeAllRanges();
                            window.getSelection().addRange(range);
                            alert('Prompt text selected. Press Ctrl+C (or Cmd+C) to copy.');
                        }
                    };
                } else {
                    alert(`‚ùå ${data.error || 'Failed to generate prompt preview'}`);
                }
            } catch (error) {
                console.error('Error fetching prompt preview:', error);
                alert('‚ùå Error fetching prompt preview');
            }
        }

        // Reset a specific transcription step
        async function resetStep(stepName) {
            const stepDisplayName = STEP_NAMES[stepName] || stepName;

            // Confirmation dialog
            const confirmMsg = `Reset ${stepDisplayName}?\n\n` +
                `This will delete the output files for this step and allow it to be re-run.\n\n` +
                `This step and all dependent steps will need to be re-processed.\n\n` +
                `Continue?`;

            if (!confirm(confirmMsg)) {
                return;
            }

            try {
                const response = await fetch('/api/recordings/{{ recording.id }}/transcription/reset-step', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ step: stepName })
                });

                const data = await response.json();

                if (data.success) {
                    // Show success message
                    let dependentMsg = '';
                    if (data.dependent_steps && data.dependent_steps.length > 0) {
                        const depNames = data.dependent_steps.map(s => STEP_NAMES[s] || s).join(', ');
                        dependentMsg = `\n\nDependent steps that will also be re-run: ${depNames}`;
                    }

                    alert(`‚úÖ ${data.message}${dependentMsg}\n\nClick "Start Transcription" to re-run from this step.`);

                    // Reload status to show updated steps
                    loadTranscriptionStatus();
                } else {
                    alert(`‚ùå ${data.error || 'Failed to reset step'}`);
                }
            } catch (error) {
                console.error('Error resetting step:', error);
                alert('‚ùå Error resetting step');
            }
        }

        // ========================================================================
        // Background Tasks Display
        // ========================================================================

        function renderBackgroundTasks(tasks) {
            const card = document.getElementById('background-tasks-card');
            const container = document.getElementById('background-tasks-container');

            // Filter for running tasks only
            const runningTasks = tasks ? tasks.filter(t => t.status === 'running') : [];

            if (!tasks || tasks.length === 0) {
                card.classList.add('hidden');
                return;
            }

            card.classList.remove('hidden');
            container.innerHTML = '';

            // Update page title with running task count
            const originalTitle = document.title;
            if (runningTasks.length > 0 && !originalTitle.startsWith('(')) {
                document.title = `(${runningTasks.length}) ${originalTitle}`;
            } else if (runningTasks.length === 0 && originalTitle.startsWith('(')) {
                document.title = originalTitle.replace(/^\(\d+\)\s*/, '');
            }

            tasks.forEach(task => {
                const taskDiv = document.createElement('div');
                const isRunning = task.status === 'running';
                const isFailed = task.status === 'failed';
                const isCompleted = task.status === 'completed';

                let statusColor = 'bg-blue-100 border-blue-300 text-blue-800';
                let statusIcon = '‚è≥';
                if (isCompleted) {
                    statusColor = 'bg-green-100 border-green-300 text-green-800';
                    statusIcon = '‚úÖ';
                } else if (isFailed) {
                    statusColor = 'bg-red-100 border-red-300 text-red-800';
                    statusIcon = '‚ùå';
                }

                taskDiv.className = `p-4 rounded-lg border-2 ${statusColor}`;

                const typeLabels = {
                    'gemini_refinement': '‚ú® Speaker Refinement (Gemini)',
                    'diarization': 'üéØ Transcription + Diarization',
                    'transcription': 'üéôÔ∏è Transcription',
                    'postprocess': 'üéµ Audio Extraction'
                };

                const typeLabel = typeLabels[task.task_type] || task.task_type;
                const elapsed = task.elapsed_seconds;
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;

                let progressHtml = '';
                if (task.progress && isRunning) {
                    progressHtml = `<div class="text-sm mt-2 text-gray-600">${escapeHtml(task.progress)}</div>`;
                }

                let errorHtml = '';
                if (task.error) {
                    errorHtml = `<div class="text-sm mt-2 text-red-600"><strong>Error:</strong> ${escapeHtml(task.error)}</div>`;
                }

                taskDiv.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <span class="text-2xl">${statusIcon}</span>
                            <div>
                                <div class="font-semibold">${typeLabel}</div>
                                <div class="text-xs text-gray-600">${task.description}</div>
                            </div>
                        </div>
                        <div class="text-right">
                            <div class="text-sm font-semibold capitalize">${task.status}</div>
                            <div class="text-xs text-gray-600">${timeStr} elapsed</div>
                        </div>
                    </div>
                    ${progressHtml}
                    ${errorHtml}
                `;

                container.appendChild(taskDiv);
            });
        }

        async function loadBackgroundTasks() {
            try {
                const response = await fetch('/api/recordings/{{ recording.id }}/background-tasks');
                const data = await response.json();

                if (data.success) {
                    renderBackgroundTasks(data.tasks);
                }
            } catch (error) {
                console.error('Error loading background tasks:', error);
            }
        }

        // Load transcription status on page load
        loadTranscriptionStatus();
        loadBackgroundTasks();

        // Poll for background tasks updates
        let backgroundTasksInterval = null;

        function startBackgroundTasksPolling() {
            // Clear any existing interval
            if (backgroundTasksInterval) {
                clearInterval(backgroundTasksInterval);
            }

            // Poll every 2 seconds
            backgroundTasksInterval = setInterval(async () => {
                await loadBackgroundTasks();

                // Check if all tasks are completed/failed
                const container = document.getElementById('background-tasks-container');
                if (container && container.children.length === 0) {
                    // No active tasks, stop polling and reload page to show updated state
                    clearInterval(backgroundTasksInterval);
                    backgroundTasksInterval = null;
                    setTimeout(() => window.location.reload(), 1000);
                }
            }, 2000);
        }

        function stopBackgroundTasksPolling() {
            if (backgroundTasksInterval) {
                clearInterval(backgroundTasksInterval);
                backgroundTasksInterval = null;
            }
        }

        // Start polling if there are initial tasks
        setTimeout(() => {
            const container = document.getElementById('background-tasks-container');
            if (container && container.children.length > 0) {
                startBackgroundTasksPolling();
            }
        }, 500);

        // Poll for transcription progress updates
        let transcriptionProgressInterval = null;

        function startTranscriptionProgressPolling() {
            // Clear any existing interval
            if (transcriptionProgressInterval) {
                clearInterval(transcriptionProgressInterval);
            }

            // Poll every 2 seconds
            transcriptionProgressInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/recordings/{{ recording.id }}/transcription-status');
                    const data = await response.json();

                    if (data.success) {
                        // Update the UI with latest status
                        renderTranscriptionSteps(data.steps || {}, data.status, data.progress);

                        // Stop polling if transcription completed or failed
                        if (data.status === 'completed' || data.status === 'failed') {
                            clearInterval(transcriptionProgressInterval);
                            transcriptionProgressInterval = null;
                        }
                    }
                } catch (error) {
                    console.error('Error polling transcription progress:', error);
                }
            }, 2000);
        }

        function stopTranscriptionProgressPolling() {
            if (transcriptionProgressInterval) {
                clearInterval(transcriptionProgressInterval);
                transcriptionProgressInterval = null;
            }
        }

        // Start polling if transcription is in progress
        {% if recording.transcription_status == 'processing' %}
        startTranscriptionProgressPolling();
        {% endif %}

        // Reset transcription status
        async function resetTranscriptionStatus() {
            if (!confirm('Reset transcription status to "pending"?\n\nThis will allow you to start transcription again if it got stuck.')) {
                return;
            }

            try {
                const response = await fetch('/api/recordings/{{ recording.id }}/transcription-status/reset', {
                    method: 'POST'
                });
                const data = await response.json();

                if (data.success) {
                    alert('‚úÖ Transcription status reset to pending');
                    window.location.reload();
                } else {
                    alert(`‚ùå ${data.error || 'Failed to reset status'}`);
                }
            } catch (error) {
                console.error('Error resetting status:', error);
                alert('‚ùå Error resetting transcription status');
            }
        }

        // Dropdown functionality for download buttons with accessibility
        function closeAllDropdowns(exceptId) {
            const allDropdowns = document.querySelectorAll('.download-dropdown > div:not(.hidden)');
            allDropdowns.forEach(d => {
                if (!exceptId || d.id !== exceptId) {
                    d.classList.add('hidden');
                }
            });

            // Reset aria-expanded on toggle buttons
            const toggles = document.querySelectorAll('.download-dropdown [aria-expanded="true"]');
            toggles.forEach(t => t.setAttribute('aria-expanded', 'false'));
        }

        function toggleDropdown(event, dropdownId) {
            event.stopPropagation();
            const dropdown = document.getElementById(dropdownId);
            if (!dropdown) return;

            // Close all other dropdowns
            closeAllDropdowns(dropdownId);

            // Toggle this dropdown
            const isHidden = dropdown.classList.contains('hidden');
            dropdown.classList.toggle('hidden');

            // Update aria-expanded on the toggle button
            const toggleButton = event.currentTarget || event.target;
            if (toggleButton && toggleButton.setAttribute) {
                toggleButton.setAttribute('aria-expanded', isHidden ? 'true' : 'false');
            }
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.download-dropdown')) {
                closeAllDropdowns();
            }
        });

        // Keyboard accessibility for dropdowns
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const hasOpenDropdown = document.querySelector('.download-dropdown > div:not(.hidden)');
                if (hasOpenDropdown) {
                    event.stopPropagation();
                    event.preventDefault();
                    closeAllDropdowns();
                }
            }
        });

        // Initialize dropdown accessibility
        function initDropdownAccessibility() {
            // Handle Enter/Space on toggle buttons
            const dropdownToggles = document.querySelectorAll('.download-dropdown button[onclick*="toggleDropdown"]');
            dropdownToggles.forEach(function(toggle) {
                toggle.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        toggle.click();
                    }
                });
            });

            // Enable arrow key navigation within menus
            const menus = document.querySelectorAll('.download-dropdown [role="menu"]');
            menus.forEach(function(menu) {
                menu.addEventListener('keydown', function(event) {
                    if (event.key !== 'ArrowDown' && event.key !== 'ArrowUp') return;

                    const items = Array.from(menu.querySelectorAll('[role="menuitem"]'))
                        .filter(el => !el.hasAttribute('disabled'));
                    if (items.length === 0) return;

                    event.preventDefault();
                    const currentIndex = items.indexOf(document.activeElement);
                    let nextIndex;

                    if (event.key === 'ArrowDown') {
                        nextIndex = currentIndex === -1 || currentIndex === items.length - 1 ? 0 : currentIndex + 1;
                    } else {
                        nextIndex = currentIndex <= 0 ? items.length - 1 : currentIndex - 1;
                    }

                    items[nextIndex].focus();
                });
            });
        }

        // Initialize on DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initDropdownAccessibility);
        } else {
            initDropdownAccessibility();
        }

        // Post-processing functionality
        let postprocessInterval = null;
        let lastPostprocessLogId = 0;

        function startPostProcessing() {
            const btn = document.getElementById('postprocess-btn');
            const btnText = document.getElementById('postprocess-btn-text');
            const btnLoading = document.getElementById('postprocess-btn-loading');
            const statusDiv = document.getElementById('postprocess-status');
            const logsDiv = document.getElementById('postprocess-logs');
            const logsContainer = document.getElementById('postprocess-logs-container');

            if (btn.disabled) return;

            if (!confirm('This will analyze the video for silence periods and split it into segments. This may take several minutes. Continue?')) {
                return;
            }

            // Disable button and show loading
            btn.disabled = true;
            btnText.classList.add('hidden');
            btnLoading.classList.remove('hidden');
            statusDiv.innerHTML = '<span class="text-orange-600">‚è≥ Analyzing video for silence periods...</span>';
            logsDiv.classList.remove('hidden');
            logsContainer.innerHTML = '';
            lastPostprocessLogId = 0;

            fetch('/api/recordings/{{ recording.id }}/postprocess', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    statusDiv.innerHTML = '<span class="text-orange-600">‚è≥ ' + data.message + '</span>';
                    // Start polling for progress
                    startPostprocessPolling();
                } else {
                    statusDiv.innerHTML = '<span class="text-red-600">‚úï Error: ' + data.error + '</span>';
                    btn.disabled = false;
                    btnText.classList.remove('hidden');
                    btnLoading.classList.add('hidden');
                    logsDiv.classList.add('hidden');
                }
            })
            .catch(error => {
                console.error('Post-processing error:', error);
                statusDiv.innerHTML = '<span class="text-red-600">‚úï Failed to start post-processing</span>';
                btn.disabled = false;
                btnText.classList.remove('hidden');
                btnLoading.classList.add('hidden');
                logsDiv.classList.add('hidden');
            });
        }

        function startPostprocessPolling() {
            if (postprocessInterval) {
                clearInterval(postprocessInterval);
            }

            postprocessInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/recordings/{{ recording.id }}/logs?since=' + lastPostprocessLogId);
                    const data = await response.json();

                    if (data.logs && data.logs.length > 0) {
                        const logsContainer = document.getElementById('postprocess-logs-container');
                        data.logs.forEach(log => {
                            if (log.id > lastPostprocessLogId) {
                                const logEntry = document.createElement('div');
                                logEntry.className = 'text-xs';
                                const timestamp = new Date(log.created_at).toLocaleTimeString();
                                const levelClass = log.level === 'error' ? 'text-red-600' : log.level === 'warning' ? 'text-orange-600' : 'text-gray-600';
                                logEntry.innerHTML = `<span class="text-gray-400">[${timestamp}]</span> <span class="${levelClass}">${log.message}</span>`;
                                logsContainer.appendChild(logEntry);
                                lastPostprocessLogId = log.id;
                            }
                        });
                        // Auto-scroll to bottom
                        logsContainer.scrollTop = logsContainer.scrollHeight;
                    }

                    // Check if post-processing completed or failed
                    const statusResponse = await fetch('/api/recordings/{{ recording.id }}');
                    const statusData = await statusResponse.json();

                    if (statusData.recording.post_process_status === 'completed') {
                        clearInterval(postprocessInterval);
                        document.getElementById('postprocess-status').innerHTML = '<span class="text-green-600">‚úì Post-processing completed</span>';
                        // Reload page after 2 seconds to show segments
                        setTimeout(() => window.location.reload(), 2000);
                    } else if (statusData.recording.post_process_status === 'failed') {
                        clearInterval(postprocessInterval);
                        document.getElementById('postprocess-status').innerHTML = '<span class="text-red-600">‚úï Post-processing failed</span>';
                        const btn = document.getElementById('postprocess-btn');
                        const btnText = document.getElementById('postprocess-btn-text');
                        const btnLoading = document.getElementById('postprocess-btn-loading');
                        btn.disabled = false;
                        btnText.classList.remove('hidden');
                        btnLoading.classList.add('hidden');
                    }
                } catch (error) {
                    console.error('Error polling post-processing status:', error);
                }
            }, 2000); // Poll every 2 seconds
        }

        // Start polling if already post-processing
        {% if recording.post_process_status == 'processing' %}
        document.addEventListener('DOMContentLoaded', () => {
            startPostprocessPolling();
        });
        {% endif %}
    </script>
</body>
</html>
